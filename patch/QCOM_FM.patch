diff --git a/frameworks/av/include/media/AudioSystem.h b/frameworks/av/include/media/AudioSystem.h
index c7ef196..f8678d2 100644
--- a/frameworks/av/include/media/AudioSystem.h
+++ b/frameworks/av/include/media/AudioSystem.h
@@ -126,6 +126,10 @@ public:
 
     static status_t setVoiceVolume(float volume);
 
+#ifdef QCOM_FM_ENABLED
+    static status_t setFmVolume(float volume);
+#endif
+
     // return the number of audio frames written by AudioFlinger to audio HAL and
     // audio dsp to DAC since the specified output I/O handle has exited standby.
     // returned status (from utils/Errors.h) can be:
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 54be5f3..8e2e145 100644
--- a/frameworks/av/include/media/IAudioFlinger.h
+++ b/frameworks/av/include/media/IAudioFlinger.h
@@ -231,6 +231,10 @@ public:
     virtual uint32_t getPrimaryOutputSamplingRate() = 0;
     virtual size_t getPrimaryOutputFrameCount() = 0;
 
+#ifdef QCOM_FM_ENABLED
+    virtual status_t setFmVolume(float volume) = 0;
+#endif
+
     // Intended for AudioService to inform AudioFlinger of device's low RAM attribute,
     // and should be called at most once.  For a definition of what "low RAM" means, see
     // android.app.ActivityManager.isLowRamDevice().
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index dda3657..5e44373 100644
--- a/frameworks/av/media/libmedia/AudioSystem.cpp
+++ b/frameworks/av/media/libmedia/AudioSystem.cpp
@@ -457,6 +457,15 @@ audio_hw_sync_t AudioSystem::getAudioHwSyncForSession(audio_session_t sessionId)
     return af->getAudioHwSyncForSession(sessionId);
 }
 
+#ifdef QCOM_FM_ENABLED
+status_t AudioSystem::setFmVolume(float value)
+{
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->setFmVolume(value);
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 void AudioSystem::AudioFlingerClient::binderDied(const wp<IBinder>& who __unused)
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index 3528243..db548a5 100644
--- a/frameworks/av/media/libmedia/IAudioFlinger.cpp
+++ b/frameworks/av/media/libmedia/IAudioFlinger.cpp
@@ -71,6 +71,9 @@ enum {
     GET_EFFECT_DESCRIPTOR,
     CREATE_EFFECT,
     MOVE_EFFECTS,
+#ifdef QCOM_FM_ENABLED
+    SET_FM_VOLUME,
+#endif
     LOAD_HW_MODULE,
     GET_PRIMARY_OUTPUT_SAMPLING_RATE,
     GET_PRIMARY_OUTPUT_FRAME_COUNT,
@@ -803,6 +806,17 @@ public:
         return reply.readInt32();
     }
 
+#ifdef QCOM_FM_ENABLED
+    virtual status_t setFmVolume(float volume)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeFloat(volume);
+        remote()->transact(SET_FM_VOLUME, data, &reply);
+        return reply.readInt32();
+    }
+#endif
+
     virtual audio_module_handle_t loadHwModule(const char *name)
     {
         Parcel data, reply;
@@ -1333,6 +1347,14 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(moveEffects(session, srcOutput, dstOutput));
             return NO_ERROR;
         } break;
+#ifdef QCOM_FM_ENABLED
+        case SET_FM_VOLUME: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            float volume = data.readFloat();
+            reply->writeInt32( setFmVolume(volume) );
+            return NO_ERROR;
+        } break;
+#endif
         case LOAD_HW_MODULE: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             reply->writeInt32(loadHwModule(data.readCString()));
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 0b2943c..cf8a8f7 100644
--- a/frameworks/av/services/audioflinger/AudioFlinger.cpp
+++ b/frameworks/av/services/audioflinger/AudioFlinger.cpp
@@ -1396,6 +1396,29 @@ status_t AudioFlinger::getRenderPosition(uint32_t *halFrames, uint32_t *dspFrame
     return BAD_VALUE;
 }
 
+#ifdef QCOM_FM_ENABLED
+status_t AudioFlinger::setFmVolume(float value)
+{
+    status_t ret = initCheck();
+    if (ret != NO_ERROR) {
+        return ret;
+    }
+
+    // check calling permissions
+    if (!settingsAllowed()) {
+        return PERMISSION_DENIED;
+    }
+
+    AutoMutex lock(mHardwareLock);
+    audio_hw_device_t *dev = mPrimaryHardwareDev->hwDevice();
+    mHardwareStatus = AUDIO_SET_FM_VOLUME;
+    ret = dev->set_fm_volume(dev, value);
+    mHardwareStatus = AUDIO_HW_IDLE;
+
+    return ret;
+}
+#endif
+
 void AudioFlinger::registerClient(const sp<IAudioFlingerClient>& client)
 {
     Mutex::Autolock _l(mLock);
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 2765db7..f32cff7 100644
--- a/frameworks/av/services/audioflinger/AudioFlinger.h
+++ b/frameworks/av/services/audioflinger/AudioFlinger.h
@@ -241,6 +241,10 @@ public:
     virtual status_t moveEffects(int sessionId, audio_io_handle_t srcOutput,
                         audio_io_handle_t dstOutput);
 
+#ifdef QCOM_FM_ENABLED
+    virtual status_t setFmVolume(float volume);
+#endif
+
     virtual audio_module_handle_t loadHwModule(const char *name);
 
     virtual uint32_t getPrimaryOutputSamplingRate();
@@ -851,6 +855,9 @@ private:
         AUDIO_HW_SET_MIC_MUTE,          // set_mic_mute
         AUDIO_HW_SET_VOICE_VOLUME,      // set_voice_volume
         AUDIO_HW_SET_PARAMETER,         // set_parameters
+#ifdef QCOM_FM_ENABLED
+        AUDIO_SET_FM_VOLUME,
+#endif
         AUDIO_HW_GET_INPUT_BUFFER_SIZE, // get_input_buffer_size
         AUDIO_HW_GET_MASTER_VOLUME,     // get_master_volume
         AUDIO_HW_GET_PARAMETER,         // get_parameters
diff --git a/services/audiopolicy/AudioPolicyClientImplLegacy.cpp b/services/audiopolicy/AudioPolicyClientImplLegacy.cpp
index 388ddaa..d0b3251 100644
--- a/frameworks/av/services/audiopolicy/AudioPolicyClientImplLegacy.cpp
+++ b/frameworks/av/services/audiopolicy/AudioPolicyClientImplLegacy.cpp
@@ -309,6 +309,15 @@ int aps_set_voice_volume(void *service, float volume, int delay_ms)
     return audioPolicyService->setVoiceVolume(volume, delay_ms);
 }
 
+#ifdef QCOM_FM_ENABLED
+int aps_set_fm_volume(void *service, float volume, int delay_ms)
+{
+    AudioPolicyService *audioPolicyService = (AudioPolicyService *)service;
+
+    return audioPolicyService->setFmVolume(volume, delay_ms);
+}
+#endif
+
 }; // extern "C"
 
 }; // namespace android
diff --git a/services/audiopolicy/AudioPolicyService.cpp b/services/audiopolicy/AudioPolicyService.cpp
index 9006e49..c92fea9 100644
--- a/frameworks/av/services/audiopolicy/AudioPolicyService.cpp
+++ b/frameworks/av/services/audiopolicy/AudioPolicyService.cpp
@@ -517,6 +517,18 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                         command->mStatus = af->setAudioPortConfig(&data->mConfig);
                     }
                     } break;
+#ifdef QCOM_FM_ENABLED
+                case SET_FM_VOLUME: {
+                    FmVolumeData *data = (FmVolumeData *)command->mParam.get();
+                    ALOGV("AudioCommandThread() processing set fm volume volume %f", data->mVolume);
+                    command->mStatus = AudioSystem::setFmVolume(data->mVolume);
+                    if (command->mWaitStatus) {
+                        command->mCond.signal();
+                        mWaitWorkCV.wait(mLock);
+                    }
+                    delete data;
+                    }break;
+#endif
                 default:
                     ALOGW("AudioCommandThread() unknown command %d", command->mCommand);
                 }
@@ -659,6 +671,51 @@ status_t AudioPolicyService::AudioCommandThread::voiceVolumeCommand(float volume
     return sendCommand(command, delayMs);
 }
 
+/*#ifdef QCOM_FM_ENABLED
+status_t AudioPolicyService::AudioCommandThread::fmVolumeCommand(float volume, int delayMs)
+{
+    status_t status = NO_ERROR;
+    AudioCommand *command = new AudioCommand();
+    command->mCommand = SET_FM_VOLUME;
+    FmVolumeData *data = new FmVolumeData();
+    data->mVolume = volume;
+    command->mParam = data;
+    if (delayMs == 0) {
+        command->mWaitStatus = true;
+    } else {
+        command->mWaitStatus = false;
+    }
+    Mutex::Autolock _l(mLock);
+    insertCommand_l(command, delayMs);
+    ALOGV("AudioCommandThread() adding set fm volume volume %f", volume);
+    mWaitWorkCV.signal();
+    if (command->mWaitStatus) {
+        command->mCond.wait(mLock);
+        status =  command->mStatus;
+        mWaitWorkCV.signal();
+    }
+    return status;
+}
+#endif */
+
+#ifdef QCOM_FM_ENABLED
+status_t AudioPolicyService::AudioCommandThread::fmVolumeCommand(float volume, int delayMs)
+{
+    sp<AudioCommand> command = new AudioCommand();
+    command->mCommand = SET_FM_VOLUME;
+    sp<FmVolumeData> data=new FmVolumeData();
+    data->mVolume = volume;
+    command->mParam = data;
+    if (delayMs == 0) {
+        command->mWaitStatus = true;
+    } else {
+        command->mWaitStatus = false;
+    }
+    ALOGV("AudioCommandThread() adding set fm volume volume %f", volume);
+    return sendCommand(command, delayMs);
+}
+#endif
+
 void AudioPolicyService::AudioCommandThread::stopOutputCommand(audio_io_handle_t output,
                                                                audio_stream_type_t stream,
                                                                int session)
@@ -891,7 +948,12 @@ void AudioPolicyService::AudioCommandThread::insertCommand_l(sp<AudioCommand>& c
             // command status as the command is now delayed
             delayMs = 1;
         } break;
-
+#ifdef QCOM_FM_ENABLED
+        case SET_FM_VOLUME: {
+           removedCommands.add(command2);
+           command->mTime = command2->mTime;
+        } break;
+#endif
         case START_TONE:
         case STOP_TONE:
         default:
@@ -962,6 +1024,13 @@ int AudioPolicyService::setStreamVolume(audio_stream_type_t stream,
                                                    output, delayMs);
 }
 
+#ifdef QCOM_FM_ENABLED
+status_t AudioPolicyService::setFmVolume(float volume, int delayMs)
+{
+    return mAudioCommandThread->fmVolumeCommand(volume, delayMs);
+}
+#endif
+
 int AudioPolicyService::startTone(audio_policy_tone_t tone,
                                   audio_stream_type_t stream)
 {
@@ -1042,6 +1111,7 @@ int aps_start_tone(void *service, audio_policy_tone_t tone,
                               audio_stream_type_t stream);
 int aps_stop_tone(void *service);
 int aps_set_voice_volume(void *service, float volume, int delay_ms);
+int aps_set_fm_volume(void *service, float volume, int delay_ms);
 };
 
 namespace {
@@ -1055,6 +1125,9 @@ namespace {
         .close_input           = aps_close_input,
         .set_stream_volume     = aps_set_stream_volume,
         .invalidate_stream     = aps_invalidate_stream,
+#ifdef QCOM_FM_ENABLED
+        .set_fm_volume         = aps_set_fm_volume,
+#endif
         .set_parameters        = aps_set_parameters,
         .get_parameters        = aps_get_parameters,
         .start_tone            = aps_start_tone,
diff --git a/services/audiopolicy/AudioPolicyService.h b/services/audiopolicy/AudioPolicyService.h
index 2e32bd0..53c9eef 100644
--- a/frameworks/av/services/audiopolicy/AudioPolicyService.h
+++ b/frameworks/av/services/audiopolicy/AudioPolicyService.h
@@ -154,6 +154,9 @@ public:
     virtual status_t startTone(audio_policy_tone_t tone, audio_stream_type_t stream);
     virtual status_t stopTone();
     virtual status_t setVoiceVolume(float volume, int delayMs = 0);
+#ifdef QCOM_FM_ENABLED
+    virtual status_t setFmVolume(float volume, int delayMs = 0);
+#endif
     virtual bool isOffloadSupported(const audio_offload_info_t &config);
 
     virtual status_t listAudioPorts(audio_port_role_t role,
@@ -222,6 +225,9 @@ private:
             SET_VOLUME,
             SET_PARAMETERS,
             SET_VOICE_VOLUME,
+#ifdef QCOM_FM_ENABLED
+            SET_FM_VOLUME,
+#endif
             STOP_OUTPUT,
             RELEASE_OUTPUT,
             CREATE_AUDIO_PATCH,
@@ -252,6 +258,9 @@ private:
                     void        stopOutputCommand(audio_io_handle_t output,
                                                   audio_stream_type_t stream,
                                                   int session);
+#ifdef QCOM_FM_ENABLED
+		    status_t    fmVolumeCommand(float volume, int delayMs);
+#endif
                     void        releaseOutputCommand(audio_io_handle_t output);
                     status_t    sendCommand(sp<AudioCommand>& command, int delayMs = 0);
                     void        insertCommand_l(sp<AudioCommand>& command, int delayMs = 0);
@@ -318,6 +327,13 @@ private:
             float mVolume;
         };
 
+#ifdef QCOM_FM_ENABLED
+        class FmVolumeData : public AudioCommandData {
+        public:
+            float mVolume;
+        };
+#endif
+
         class StopOutputData : public AudioCommandData {
         public:
             audio_io_handle_t mIO;
